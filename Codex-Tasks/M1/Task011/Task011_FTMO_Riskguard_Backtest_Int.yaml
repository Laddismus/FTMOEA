title: AFTS_M1_Task_011_FTMO_RiskGuard_Backtest_Integration_v1

summary: |
  Integriere einen ersten FTMO-inspirierten RiskGuard in den Research-Backtest-Stack.
  Ziel ist, dass jeder Backtest optional mit FTMO-ähnlichen Risk-Constraints bewertet wird:
    - Max Daily Loss (in % vom Initialkapital),
    - Max Overall Loss (in % vom Initialkapital),
    - optionaler Sicherheits-Puffer (z. B. 4% / 8.5% statt 5% / 10%),
  und das Ergebnis (Pass/Fail + Detail-Metriken) im BacktestResult landet.

  WICHTIG:
    - Dieser Task bewertet nur das bestehende Equity-/Return-Path der Backtests.
      Er blockiert noch keine Trades, sondern liefert einen Risk-Report.
    - Spätere Tasks können den RiskGuard nutzen, um Backtests „hart“ zu stoppen oder
      Live-/SIM-Execution zu kontrollieren.

inputs:
  - Bestehender Backtest-Stack:
      - research_lab/backend/core/backtests/models.py
          - BacktestBar (ts, OHLCV)
          - BacktestRequest (bars, returns, cost_model, strategy_params, metadata, ...)
          - BacktestResult (kpi_summary, trades, strategy_metadata, created_at, ...)
      - research_lab/backend/core/backtests/engine.py
          - RollingKpiBacktestEngine mit Returns-Berechnung (python+bars, legacy returns)
      - research_lab/backend/core/backtests/persistence.py
          - Speicherung/Laden von BacktestResult als JSON
      - research_lab/backend/core/backtests/service.py
          - Erstellung von BacktestResult, Persistenz, JobRunner-Integration
      - research_lab/backend/core/strategy_execution/python_executor.py
          - Bar-Loop, Trading-State, Trades, Returns (Long/Short, Size, Costs)
      - Zeitstempel-Handling:
          - research_lab/backend/core/backtests/models.py (ensure_utc_datetime)
          - tests sind auf tz-aware UTC angepasst
  - FTMO-Kontext:
      - Bisherige FTMO-Logik in src/afts_pro/risk/ftmo_plus.py (nur zur Orientierung; die Research-Variante
        kann als eigene, vereinfachte Implementierung entstehen).
      - Ziel-Rules:
          - Max Daily Loss (z. B. 5% vom Startkapital, in der Praxis mit Puffer 4%),
          - Max Overall Loss (z. B. 10% vom Initialkapital, Puffer 8.5%),
          - Bewertung pro Backtest-Run (hat Backtest die Regeln verletzt, ja/nein, wann, wie stark).

outputs:
  - RiskGuard-Domain-Modelle:
      - Neues Core-Paket: research_lab/backend/core/risk_guard/__init__.py
      - research_lab/backend/core/risk_guard/models.py
          - FTMO-inspirierte Konfigurations- und Ergebnis-Modelle:

            ```python
            class FtmoRiskConfig(BaseModel):
                initial_equity: float = 1.0
                max_daily_loss_pct: float = 0.05        # z. B. 5% (FTMO-Regel)
                max_total_loss_pct: float = 0.10        # z. B. 10%
                safety_buffer_pct: float = 0.0          # z. B. 0.01 für 1%-Puffer
                # optional: in Zukunft Rules für Min-Trading-Tage, Max Daily Profit Cap etc.

            class FtmoBreachType(str, Enum):
                NONE = "none"
                DAILY = "daily"
                TOTAL = "total"

            class FtmoRiskEvent(BaseModel):
                ts: datetime
                breach_type: FtmoBreachType
                equity: float
                drawdown_pct: float
                day: date

            class FtmoRiskSummary(BaseModel):
                passed: bool
                first_breach: FtmoRiskEvent | None = None
                worst_daily_drawdown_pct: float
                worst_total_drawdown_pct: float
                config: FtmoRiskConfig
                # Optional zusätzliche Metriken:
                # - daily_drawdowns: dict[str, float]
                # - equity_min: float
                # - equity_max: float
            ```

  - RiskGuard-Logik:
      - research_lab/backend/core/risk_guard/ftmo_guard.py
          - Implementiere eine reine Logik-Funktion/Klasse, die aus:
              - einer Serie von Returns (per_bar_return),
              - den zugehörigen Zeitstempeln (BacktestBar.ts),
              - und einer FtmoRiskConfig
            eine FtmoRiskSummary berechnet.

          - Vorschlag Interface:

            ```python
            class FtmoRiskGuard:
                def __init__(self, config: FtmoRiskConfig):
                    self.config = config

                def evaluate(
                    self,
                    bars: Sequence[BacktestBar],
                    returns: Sequence[float],
                ) -> FtmoRiskSummary:
                    ...
            ```

          - Berechnungslogik (vereinfachte FTMO-Interpretation):

              - Starte mit `equity = config.initial_equity` (z. B. 1.0).
              - Definiere Grenzen mit Sicherheits-Puffer:

                ```python
                max_daily_loss_limit = config.max_daily_loss_pct - config.safety_buffer_pct
                max_total_loss_limit = config.max_total_loss_pct - config.safety_buffer_pct
                ```

              - Für jede Bar i (in zeitlicher Reihenfolge, bars[i].ts, returns[i]):

                  - equity *= (1.0 + returns[i])

                  - Bestimme `day_key = bars[i].ts.date()` (UTC).
                  - Tracke für jeden Tag:
                      - day_start_equity (erste Equity des Tages, basierend auf letzter Bar des Vortages oder initial_equity),
                      - day_min_equity,
                      - day_max_equity (optional).

                  - Total-Drawdown:
                      - `total_drawdown_pct = (config.initial_equity - equity) / config.initial_equity`
                      - Wenn `total_drawdown_pct >= max_total_loss_limit` → TOTAL-Breach.

                  - Daily-Drawdown:
                      - `daily_drawdown_pct = (day_start_equity - day_min_equity) / config.initial_equity`
                        (FTMO misst eigentlich vs. initial_equity, nicht vs. day_start; wir bleiben konsistent
                        mit FTMO: Verlust des Tages relativ zum initial equity.)
                      - Wenn `daily_drawdown_pct >= max_daily_loss_limit` → DAILY-Breach.

                  - Tracke:
                      - worst_total_drawdown_pct = max(worst_total_drawdown_pct, total_drawdown_pct)
                      - worst_daily_drawdown_pct = max(worst_daily_drawdown_pct, daily_drawdown_pct)

              - Bestimme first_breach:
                  - Der erste Zeitpunkt, an dem eine der beiden Regeln verletzt wurde.
                  - ftmo_breach_type: DAILY oder TOTAL.
                  - equity zum Zeitpunkt des Breaches.
                  - drawdown_pct entsprechend.

              - Summary:
                  - passed = (first_breach is None)
                  - first_breach = FtmoRiskEvent oder None
                  - worst_daily_drawdown_pct, worst_total_drawdown_pct (in [0, 1] Bereich)
                  - config = FtmoRiskConfig (wie genutzt).

  - Backtest-Models-Erweiterung:
      - In research_lab/backend/core/backtests/models.py:
          - Importiere FtmoRiskConfig, FtmoRiskSummary.
          - Ergänze BacktestRequest um optionales FTMO-RiskConfig-Feld:

            ```python
            class BacktestRequest(BaseModel):
                ...
                ftmo_risk: FtmoRiskConfig | None = None
            ```

          - Ergänze BacktestResult um optionalen Risk-Report:

            ```python
            class BacktestResult(BaseModel):
                ...
                ftmo_risk_summary: FtmoRiskSummary | None = None
            ```

          - Stelle sicher, dass Pydantic-Forward-Refs / ensure_utc_datetime etc. weiterhin sauber funktionieren.

  - Integration in BacktestEngine:
      - In research_lab/backend/core/backtests/engine.py:
          - Nach Berechnung der Returns (egal ob Python-Bar-Loop oder legacy returns):

            - Falls `request.ftmo_risk` gesetzt ist:
                - Instanziere `FtmoRiskGuard(config=request.ftmo_risk)`.
                - Rufe `evaluate(bars=request.bars or synthetic_bars, returns=returns)` auf.

                - WICHTIG:
                    - Für mode="python" + bars:
                        - Bars vorhanden → normal verwenden.
                    - Für Legacy-Backtests mit returns aber ohne bars:
                        - Zwei Optionen:
                            1) FTMO-Risk nur ausführen, wenn bars vorhanden (klar dokumentieren und Tests darauf ausrichten).
                            2) Für diesen Task: nur python+bars unterstützen und Legacy returns-only ignorieren.
                          Empfehlung: Variante (1) – wenn keine bars, setze ftmo_risk_summary=None oder dokumentiere,
                          dass RiskGuard nur mit Bars arbeitet.

                - Ergebnis `FtmoRiskSummary` in `BacktestResult.ftmo_risk_summary` speichern.

          - Stelle sicher, dass:
              - Der RiskGuard die Returns so nutzt, wie sie zuvor auch für KPI-Berechnung verwendet wurden
                (also inklusive Costs).

  - API-Integration:
      - In research_lab/backend/app/api/backtests.py:
          - Request-Schema:
              - `BacktestRequest` (oder API-Spiegelmodell) soll ftmo_risk aufnehmen:

                ```json
                "ftmo_risk": {
                  "initial_equity": 1.0,
                  "max_daily_loss_pct": 0.05,
                  "max_total_loss_pct": 0.10,
                  "safety_buffer_pct": 0.015
                }
                ```

          - Response-Schema:
              - BacktestResult enthält nun (falls gesetzt) das Feld ftmo_risk_summary.
          - Bestehende Endpoints (/run-sync, /submit, /jobs/{id}, /runs, /runs/{id}) funktionieren unverändert,
            liefern nur zusätzliche Daten im JSON.

  - Tests (pytest) – neu/erweitert:
      - tests/research_lab/backend/test_ftmo_risk_guard_logic.py
          - Fokus: pure RiskGuard-Logik, ohne Engine/HTTP.

          - Szenario 1: Kein Breach
              - Bars: Tagesreturns, die nie mehr als z. B. 3% Drawdown erzeugen.
              - Config: max_daily_loss_pct=0.05, max_total_loss_pct=0.10, safety_buffer_pct=0.0.
              - Erwartung:
                  - summary.passed == True
                  - first_breach is None
                  - worst_daily_drawdown_pct < 0.05
                  - worst_total_drawdown_pct < 0.10

          - Szenario 2: Daily-Breach
              - Erzeuge Returns so, dass an einem Tag > 5% Verlust entsteht, aber Overall < 10%.
              - Erwartung:
                  - summary.passed == False
                  - first_breach.breach_type == DAILY
                  - worst_daily_drawdown_pct >= max_daily_loss_pct - safety_buffer
                  - worst_total_drawdown_pct < max_total_loss_pct

          - Szenario 3: Total-Breach
              - Über mehrere Tage kumuliert > 10% Verlust.
              - Erwartung:
                  - summary.passed == False
                  - first_breach.breach_type == TOTAL
                  - worst_total_drawdown_pct >= max_total_loss_pct - safety_buffer

      - tests/research_lab/backend/test_backtest_engine_with_ftmo_risk.py
          - Nutzt RollingKpiBacktestEngine + Python-Bar-Loop oder einfache returns.

          - Setup:
              - Bars mit definierter ts (UTC).
              - Returns-Serie, die z. B. Daily-Breach erzeugt.
              - BacktestRequest:
                  - mode="python"
                  - bars, returns (oder nur bars, returns aus Strategy)
                  - ftmo_risk mit bekannten Limits.

          - Erwartung:
              - result.ftmo_risk_summary ist nicht None.
              - result.ftmo_risk_summary.passed == False im Breach-Szenario.
              - worst_daily_drawdown_pct/worst_total_drawdown_pct plausibel.

      - tests/research_lab/backend/test_backtests_api_ftmo_risk.py
          - FastAPI TestClient.

          - Szenario 1: Pass
              - POST /api/backtests/run-sync mit ftmo_risk-Config und „harmlosen“ Returns/Bars.
              - Erwartung:
                  - Response 200.
                  - ftmo_risk_summary.passed == True.

          - Szenario 2: Breach
              - POST /api/backtests/run-sync mit ftmo_risk-Config und Returns, die Daily- oder Total-Breach erzeugen.
              - Erwartung:
                  - ftmo_risk_summary.passed == False.
                  - ftmo_risk_summary.first_breach.breach_type == "daily" oder "total".

acceptance: |
  Dieser Task ist DONE, wenn:

  1. RiskGuard-Domain:
     - FtmoRiskConfig, FtmoRiskEvent, FtmoRiskSummary sind in research_lab/backend/core/risk_guard/models.py definiert.
     - FtmoRiskGuard in ftmo_guard.py implementiert evaluate(bars, returns) und liefert eine konsistente Summary.

  2. Backtest-Models:
     - BacktestRequest besitzt ein optionales Feld ftmo_risk vom Typ FtmoRiskConfig.
     - BacktestResult besitzt ein optionales Feld ftmo_risk_summary vom Typ FtmoRiskSummary.
     - Pydantic/Forward-Refs/Datetime-Handling bleiben stabil.

  3. Engine-Integration:
     - RollingKpiBacktestEngine ruft FtmoRiskGuard.evaluate auf, wenn ftmo_risk im Request gesetzt ist
       und Bars + Returns verfügbar sind.
     - BacktestResult.ftmo_risk_summary ist im Testfall korrekt befüllt.
     - Wenn ftmo_risk nicht gesetzt ist oder Bars fehlen, bleibt ftmo_risk_summary None
       (oder wird sauber dokumentiert/ignoriert).

  4. API:
     - /api/backtests/run-sync, /submit, /jobs/{id}, /runs, /runs/{id} akzeptieren ftmo_risk im Request
       und liefern ftmo_risk_summary im Response, sofern gesetzt.
     - Ein API-Test weist nach, dass bei einem Breach ftmo_risk_summary.passed == False ist.

  5. Tests:
     - Alle neuen Tests:
         - test_ftmo_risk_guard_logic.py
         - test_backtest_engine_with_ftmo_risk.py
         - test_backtests_api_ftmo_risk.py
       sind implementiert und grün.
     - Bestehende Tests bleiben grün (ggf. minimale Anpassungen wegen neuer Felder).
     - Gesamt-`pytest` im Projekt-Root (afts_pro) läuft ohne Errors/Failures.

  6. Qualität:
     - Vollständige Type Hints und Docstrings für:
         - FtmoRiskConfig, FtmoRiskSummary, FtmoRiskGuard.evaluate.
         - Erklärung der vereinfachten FTMO-Interpretation (wie Daily-/Total-Drawdown berechnet werden).
     - Design so, dass später:
         - Hard-Stops (Backtest stoppen bei Breach),
         - Live-/SIM-RiskGuard,
         - Multi-Account / Multi-Asset-Auswertung
       ohne Breaking Changes auf diesem Modul aufsetzen können.

coding_standards: |
  - Python >= 3.11.
  - Nutzung von datetime (tz-aware, UTC), date, Enums.
  - Kein externes Zeitzonen-Framework; alles basiert auf UTC.
  - RiskGuard-Logik im Core (risk_guard/*), Router bleibt schlank.
  - Tests deterministisch, Float-Checks mit pytest.approx.

notes: |
  - Dieser Task hebt den Backtester von „nur PnL+KPIs“ auf „FTMO-Regel-awareness“:
      - Du siehst pro Backtest sofort, ob die Strategie FTMO-konform wäre
        (unter den konfigurierten Limits + Puffer).
  - Spätere Tasks können:
      - den RiskGuard nutzen, um Backtests hart abzubrechen,
      - Risk/PnL-Heatmaps zu bauen,
      - und Live-/SIM-Execution über denselben Mechanismus absichern („FTMO Sicherungsgurt“).
